package com.github.niemals.stop.dcr

import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.databind.ObjectMapper
import com.github.dockerjava.api.DockerClient
import com.github.dockerjava.api.async.ResultCallback
import com.github.dockerjava.api.command.CreateContainerCmd
import com.github.dockerjava.api.command.CreateContainerResponse
import com.github.dockerjava.api.command.InspectContainerResponse
import com.github.dockerjava.api.model.Bind
import com.github.dockerjava.api.model.Frame
import com.github.dockerjava.api.model.HostConfig
import com.github.dockerjava.api.model.PortBinding
import com.google.common.collect.ImmutableMap
import org.apache.commons.lang3.StringUtils
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.logging.Logger

import java.util.concurrent.TimeUnit
import java.util.regex.Pattern
import java.util.stream.Collectors
import java.util.stream.Stream

class ContainerNetworkSpec {
    String name;
    String alias;

    String getName() {
        return name
    }
}

class WaitFor {
    String log
    Integer timeout

    @Override
    public String toString() {
        return "WaitFor{log='$log', timeout=$timeout}";
    }
}

class ContainerSpec {
    final String name
    String image
    String[] ports
    String portsFile;
    Map<String, String> envVars;
    Map<String, String> volumes;
    WaitFor waitFor = new WaitFor();
    ContainerNetworkSpec network = new ContainerNetworkSpec();

    ContainerSpec(String name) {
        this.name = name
    }

    void waitFor(Closure<?> closure) {
        closure.setDelegate(waitFor)
        closure.call()
    }

    void network(Closure<?> closure) {
        closure.setDelegate(network)
        closure.call()
    }
}

class DockerContainerNetwork {
    String name;
    String[] aliases;
}

@JsonIgnoreProperties(ignoreUnknown = true)
class Container {
    /**
     * A container id generated by docker daemon
     */
    String id

    /**
     * A randomized container name that provided to the docker daemon.
     */
    String name;

    /**
     * A container name from the spec. It's used as a prefix for the actual container name.
     */
    String nameSpec;

    Map<String, String> portsMapping

    List<DockerContainerNetwork> networks;

    @JsonIgnore
    String getShortId() {
        return id == null ? null : id.substring(0, 8)
    }
}

class DockerTestContainersPlugin implements Plugin<Project> {

    private static final String PLUGIN_NAME = "dockerTestContainers"

    void apply(Project project) {
        def dockerTestContainers = project.container(ContainerSpec)
        project.extensions.dockerTestContainers = dockerTestContainers
        project.task('runTestContainers') {
            doLast {
                if (dockerTestContainers.isEmpty()) {
                    return
                }
                DockerClient client = DockerClientFactory.localhost()
                dockerTestContainers.each { containerSpec ->
                    File stateFile = getStateFile(project, containerSpec)
                    Container container = getRunningContainer(client, stateFile, project)
                    if (container == null) {
                        container = runContainer(client, containerSpec, project)
                        saveContainerState(container, stateFile, project)
                    }
                    if (containerSpec.portsFile) {
                        writePortsFileAsProperties(container, containerSpec.portsFile, project)
                    }
                }
                client.close()
            }
        }

        project.task('stopTestContainers') {
            doLast {
                if (dockerTestContainers.isEmpty()) {
                    return
                }
                DockerClient client = DockerClientFactory.localhost()
                dockerTestContainers.each { containerSpec ->
                    File stateFile = getStateFile(project, containerSpec)
                    client.listContainersCmd()
                            .withLabelFilter(buildContainerLabels(project))
                            .exec()
                            .each { container ->
                                client.stopContainerCmd(container.id)
                                        .exec()
                                project.getLogger().info("${container.names} ${container.id} - stopped.")
                            }
                    if (stateFile.exists()) {
                        stateFile.delete()
                    }
                }
                client.close()
            }
        }
    }

    private static Container runContainer(DockerClient client, ContainerSpec containerSpec, Project project) {
        Logger logger = project.getLogger();
        Container container = new Container()
        container.nameSpec = containerSpec.name
        container.name = containerSpec.name + "-" + UUID.randomUUID().toString().substring(0, 7).toLowerCase(Locale.ENGLISH);
        List<String> aliases = Optional.ofNullable(containerSpec.getNetwork())
                .map(networkSpec -> networkSpec.getAlias())
                .map(alias -> Collections.singletonList(alias))
                .orElse(Collections.emptyList())

        CreateContainerCmd createContainerCmd = client.createContainerCmd(containerSpec.image)
                .withName(container.name)
                .withLabels(buildContainerLabels(project))
                .withEnv((containerSpec.envVars == null ? Collections.emptyMap() : containerSpec.envVars)
                        .entrySet()
                        .stream()
                        .map(e -> e.key + '=' + e.value)
                        .collect(Collectors.toList()));

        if (!aliases.isEmpty()) {
            createContainerCmd = createContainerCmd.withAliases(aliases)
        }

        CreateContainerResponse response = createContainerCmd.withHostConfig(new HostConfig()
                .withBinds((containerSpec.volumes == null ? Collections.emptyMap() : containerSpec.volumes)
                        .entrySet()
                        .stream()
                        .map(e -> Bind.parse(e.key + ":" + e.value))
                        .collect(Collectors.toList()))
                .withNetworkMode(Optional.ofNullable(containerSpec.getNetwork())
                        .map(networkSpec -> networkSpec.getName())
                        .orElse(null))
                .withPortBindings(Stream.of(containerSpec.ports)
                        .filter(StringUtils::isNotBlank)
                        .map(PortBinding::parse)
                        .filter(Objects::nonNull)
                        .collect(Collectors.toList())))
                .exec()
        container.id = response.id;
        String logPrefix = "[$container.name $container.shortId]>"
        response.warnings.each { warn -> logger.warn("${logPrefix} ${warn}") }
        logger.info("${logPrefix} - created.")

        client.startContainerCmd(container.id)
                .exec()
        logger.info("${logPrefix} - started.")

        int timeout = (containerSpec.waitFor == null || containerSpec.waitFor.timeout == null) ? 300 : containerSpec.waitFor.timeout

        Pattern logPattern = null
        if (containerSpec.waitFor != null && containerSpec.waitFor.log != null) {
            logPattern = Pattern.compile(containerSpec.waitFor.log, Pattern.MULTILINE);
        }

        ResultCallback.Adapter<Frame> callback = new ResultCallback.Adapter<Frame>() {
            @Override
            void onNext(Frame frame) {
                String logEntry = new String(frame.getPayload())
                logger.info("${logPrefix} {} > {}", frame.streamType, logEntry.substring(0, logEntry.length() - 1))
                if (logPattern != null && logPattern.asPredicate().test(logEntry.toString())) {
                    onComplete()
                }
            }
        }

        logger.info("${logPrefix} - waiting for startup with timeout=${timeout}s logPattern=${logPattern}")
        client.logContainerCmd(container.id)
                .withStdOut(true)
                .withStdErr(true)
                .withTailAll()
                .withTimestamps(true)
                .exec(callback)
                .awaitCompletion(timeout, TimeUnit.SECONDS)

        InspectContainerResponse inspectContainerResponse = client.inspectContainerCmd(container.id)
                .exec()

        container.networks = inspectContainerResponse.getNetworkSettings()
                .getNetworks()
                .entrySet()
                .stream()
                .map(e -> {
                    DockerContainerNetwork network = new DockerContainerNetwork()
                    network.name = e.getKey()
                    network.aliases = e.getValue().getAliases().stream().toArray(String[]::new)
                    return network
                })
                .collect(Collectors.toList())
        container.portsMapping = new HashMap<>()
        inspectContainerResponse.getNetworkSettings()
                .getPorts()
                .getBindings()
                .entrySet()
                .forEach(e -> {
                    if (container.portsMapping != null && e.getValue() != null && e.getValue().length >= 1) {
                        container.portsMapping.put(String.valueOf(e.getKey().getPort()), e.getValue()[0].hostPortSpec)
                    }
                })
        return container
    }

    static ImmutableMap<String, String> buildContainerLabels(Project project) {
        return ImmutableMap.of(
                "project", project.name,
                "managedBy", PLUGIN_NAME
        )
    }

    static void saveContainerState(Container container, File dstFile, Project project) {
        dstFile.text = new ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(container)
        project.getLogger().info("State of ${container.name} saved at ${dstFile}")
    }

    static File getStateFile(Project project, ContainerSpec containerSpec) {
        File stateFile = project.file("${project.buildDir}/tmp/${PLUGIN_NAME}/${containerSpec.name}.run")
        createFile(stateFile)
        return stateFile;
    }

    static Container getRunningContainer(DockerClient client, File stateFile, Project project) {
        Logger logger = project.getLogger()
        if (!stateFile.exists() || stateFile.length() == 0) {
            return
        }
        try {
            Container container = new ObjectMapper().readValue(stateFile, Container.class)
            String logPrefix = "[$container.name $container.shortId]>"
            InspectContainerResponse response = client.inspectContainerCmd(container.id)
                    .exec()
            if (response.state.running) {
                logger.info("${logPrefix} - already running. Skipped.")
                return container
            } else {
                return null
            }
        } catch (final Exception e) {
            logger.warn("Unable to deserialize state file ${stateFile.absolutePath} - ${e.message}")
            return null
        }
    }

    static void writePortsFileAsProperties(Container container, String portsFile, Project project) {
        File f = project.file(portsFile)
        createFile(f)
        try (FileOutputStream stream = new FileOutputStream(f)) {
            Properties props = new Properties()
            if (container.portsMapping != null) {
                container.portsMapping.forEach((port, dynamicPort) -> {
                    props.put('container.' + container.nameSpec + '.host', "localhost")
                    props.put('container.' + container.nameSpec + '.port.' + port, dynamicPort)
                })
                props.store(stream, "Generated for ${container.nameSpec} / ${container.name} / ${container.id}")
            }
        }
    }

    static void createFile(File f) {
        if (!f.exists()) {
            f.parentFile.mkdirs()
            f.createNewFile()
        }
    }
}
